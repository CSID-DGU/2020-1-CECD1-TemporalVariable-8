// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"lightServer/ent/authorize"
	"lightServer/ent/category"
	"lightServer/ent/file"
	"lightServer/ent/history"
	"lightServer/ent/menu"
	"lightServer/ent/order"
	"lightServer/ent/orderfield"
	"lightServer/ent/restaurant"
	"lightServer/ent/review"
	"lightServer/ent/user"
	"net/url"
	"sync"
	"time"

	"github.com/Rhymond/go-money"
	"github.com/facebook/ent"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthorize  = "Authorize"
	TypeCategory   = "Category"
	TypeFile       = "File"
	TypeHistory    = "History"
	TypeMenu       = "Menu"
	TypeOrder      = "Order"
	TypeOrderField = "OrderField"
	TypeRestaurant = "Restaurant"
	TypeReview     = "Review"
	TypeUser       = "User"
)

// AuthorizeMutation represents an operation that mutate the Authorizes
// nodes in the graph.
type AuthorizeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	provider      *authorize.Provider
	service_id    *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Authorize, error)
}

var _ ent.Mutation = (*AuthorizeMutation)(nil)

// authorizeOption allows to manage the mutation configuration using functional options.
type authorizeOption func(*AuthorizeMutation)

// newAuthorizeMutation creates new mutation for $n.Name.
func newAuthorizeMutation(c config, op Op, opts ...authorizeOption) *AuthorizeMutation {
	m := &AuthorizeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorize,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizeID sets the id field of the mutation.
func withAuthorizeID(id int) authorizeOption {
	return func(m *AuthorizeMutation) {
		var (
			err   error
			once  sync.Once
			value *Authorize
		)
		m.oldValue = func(ctx context.Context) (*Authorize, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Authorize.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorize sets the old Authorize of the mutation.
func withAuthorize(node *Authorize) authorizeOption {
	return func(m *AuthorizeMutation) {
		m.oldValue = func(context.Context) (*Authorize, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AuthorizeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvider sets the provider field.
func (m *AuthorizeMutation) SetProvider(a authorize.Provider) {
	m.provider = &a
}

// Provider returns the provider value in the mutation.
func (m *AuthorizeMutation) Provider() (r authorize.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old provider value of the Authorize.
// If the Authorize object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AuthorizeMutation) OldProvider(ctx context.Context) (v authorize.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvider is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider reset all changes of the "provider" field.
func (m *AuthorizeMutation) ResetProvider() {
	m.provider = nil
}

// SetServiceID sets the service_id field.
func (m *AuthorizeMutation) SetServiceID(s string) {
	m.service_id = &s
}

// ServiceID returns the service_id value in the mutation.
func (m *AuthorizeMutation) ServiceID() (r string, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the Authorize.
// If the Authorize object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AuthorizeMutation) OldServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *AuthorizeMutation) ResetServiceID() {
	m.service_id = nil
}

// SetUserID sets the user edge to User by id.
func (m *AuthorizeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *AuthorizeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *AuthorizeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *AuthorizeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthorizeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *AuthorizeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *AuthorizeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Authorize).
func (m *AuthorizeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AuthorizeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.provider != nil {
		fields = append(fields, authorize.FieldProvider)
	}
	if m.service_id != nil {
		fields = append(fields, authorize.FieldServiceID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AuthorizeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorize.FieldProvider:
		return m.Provider()
	case authorize.FieldServiceID:
		return m.ServiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AuthorizeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorize.FieldProvider:
		return m.OldProvider(ctx)
	case authorize.FieldServiceID:
		return m.OldServiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Authorize field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthorizeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorize.FieldProvider:
		v, ok := value.(authorize.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case authorize.FieldServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Authorize field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AuthorizeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AuthorizeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthorizeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Authorize numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AuthorizeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AuthorizeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Authorize nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AuthorizeMutation) ResetField(name string) error {
	switch name {
	case authorize.FieldProvider:
		m.ResetProvider()
		return nil
	case authorize.FieldServiceID:
		m.ResetServiceID()
		return nil
	}
	return fmt.Errorf("unknown Authorize field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AuthorizeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, authorize.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AuthorizeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorize.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AuthorizeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AuthorizeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AuthorizeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, authorize.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AuthorizeMutation) EdgeCleared(name string) bool {
	switch name {
	case authorize.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AuthorizeMutation) ClearEdge(name string) error {
	switch name {
	case authorize.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Authorize unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AuthorizeMutation) ResetEdge(name string) error {
	switch name {
	case authorize.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Authorize edge %s", name)
}

// CategoryMutation represents an operation that mutate the Categories
// nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	menus         map[int]struct{}
	removedmenus  map[int]struct{}
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows to manage the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for $n.Name.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the id field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the owner edge to Restaurant by id.
func (m *CategoryMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Restaurant.
func (m *CategoryMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *CategoryMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *CategoryMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *CategoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddMenuIDs adds the menus edge to Menu by ids.
func (m *CategoryMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the menus edge to Menu.
func (m *CategoryMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared returns if the edge menus was cleared.
func (m *CategoryMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the menus edge to Menu by ids.
func (m *CategoryMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed ids of menus.
func (m *CategoryMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the menus ids in the mutation.
func (m *CategoryMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus reset all changes of the "menus" edge.
func (m *CategoryMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, category.EdgeOwner)
	}
	if m.menus != nil {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, category.EdgeOwner)
	}
	if m.clearedmenus {
		edges = append(edges, category.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeOwner:
		return m.clearedowner
	case category.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeOwner:
		m.ResetOwner()
		return nil
	case category.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// FileMutation represents an operation that mutate the Files
// nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	file_id       *uuid.UUID
	mime          *string
	name          *string
	create_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*File, error)
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows to manage the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for $n.Name.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the id field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFileID sets the file_id field.
func (m *FileMutation) SetFileID(u uuid.UUID) {
	m.file_id = &u
}

// FileID returns the file_id value in the mutation.
func (m *FileMutation) FileID() (r uuid.UUID, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old file_id value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldFileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID reset all changes of the "file_id" field.
func (m *FileMutation) ResetFileID() {
	m.file_id = nil
}

// SetMime sets the mime field.
func (m *FileMutation) SetMime(s string) {
	m.mime = &s
}

// Mime returns the mime value in the mutation.
func (m *FileMutation) Mime() (r string, exists bool) {
	v := m.mime
	if v == nil {
		return
	}
	return *v, true
}

// OldMime returns the old mime value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldMime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMime: %w", err)
	}
	return oldValue.Mime, nil
}

// ResetMime reset all changes of the "mime" field.
func (m *FileMutation) ResetMime() {
	m.mime = nil
}

// SetName sets the name field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetCreateAt sets the create_at field.
func (m *FileMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the create_at value in the mutation.
func (m *FileMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old create_at value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt reset all changes of the "create_at" field.
func (m *FileMutation) ResetCreateAt() {
	m.create_at = nil
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.file_id != nil {
		fields = append(fields, file.FieldFileID)
	}
	if m.mime != nil {
		fields = append(fields, file.FieldMime)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.create_at != nil {
		fields = append(fields, file.FieldCreateAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldFileID:
		return m.FileID()
	case file.FieldMime:
		return m.Mime()
	case file.FieldName:
		return m.Name()
	case file.FieldCreateAt:
		return m.CreateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldFileID:
		return m.OldFileID(ctx)
	case file.FieldMime:
		return m.OldMime(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldCreateAt:
		return m.OldCreateAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldFileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case file.FieldMime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMime(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldFileID:
		m.ResetFileID()
		return nil
	case file.FieldMime:
		m.ResetMime()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown File edge %s", name)
}

// HistoryMutation represents an operation that mutate the Histories
// nodes in the graph.
type HistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	open_at       *time.Time
	close_at      *time.Time
	clearedFields map[string]struct{}
	of            map[int]struct{}
	removedof     map[int]struct{}
	clearedof     bool
	done          bool
	oldValue      func(context.Context) (*History, error)
}

var _ ent.Mutation = (*HistoryMutation)(nil)

// historyOption allows to manage the mutation configuration using functional options.
type historyOption func(*HistoryMutation)

// newHistoryMutation creates new mutation for $n.Name.
func newHistoryMutation(c config, op Op, opts ...historyOption) *HistoryMutation {
	m := &HistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistoryID sets the id field of the mutation.
func withHistoryID(id int) historyOption {
	return func(m *HistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *History
		)
		m.oldValue = func(ctx context.Context) (*History, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().History.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistory sets the old History of the mutation.
func withHistory(node *History) historyOption {
	return func(m *HistoryMutation) {
		m.oldValue = func(context.Context) (*History, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOpenAt sets the open_at field.
func (m *HistoryMutation) SetOpenAt(t time.Time) {
	m.open_at = &t
}

// OpenAt returns the open_at value in the mutation.
func (m *HistoryMutation) OpenAt() (r time.Time, exists bool) {
	v := m.open_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenAt returns the old open_at value of the History.
// If the History object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistoryMutation) OldOpenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpenAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenAt: %w", err)
	}
	return oldValue.OpenAt, nil
}

// ResetOpenAt reset all changes of the "open_at" field.
func (m *HistoryMutation) ResetOpenAt() {
	m.open_at = nil
}

// SetCloseAt sets the close_at field.
func (m *HistoryMutation) SetCloseAt(t time.Time) {
	m.close_at = &t
}

// CloseAt returns the close_at value in the mutation.
func (m *HistoryMutation) CloseAt() (r time.Time, exists bool) {
	v := m.close_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseAt returns the old close_at value of the History.
// If the History object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistoryMutation) OldCloseAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCloseAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCloseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseAt: %w", err)
	}
	return oldValue.CloseAt, nil
}

// ResetCloseAt reset all changes of the "close_at" field.
func (m *HistoryMutation) ResetCloseAt() {
	m.close_at = nil
}

// AddOfIDs adds the of edge to Restaurant by ids.
func (m *HistoryMutation) AddOfIDs(ids ...int) {
	if m.of == nil {
		m.of = make(map[int]struct{})
	}
	for i := range ids {
		m.of[ids[i]] = struct{}{}
	}
}

// ClearOf clears the of edge to Restaurant.
func (m *HistoryMutation) ClearOf() {
	m.clearedof = true
}

// OfCleared returns if the edge of was cleared.
func (m *HistoryMutation) OfCleared() bool {
	return m.clearedof
}

// RemoveOfIDs removes the of edge to Restaurant by ids.
func (m *HistoryMutation) RemoveOfIDs(ids ...int) {
	if m.removedof == nil {
		m.removedof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedof[ids[i]] = struct{}{}
	}
}

// RemovedOf returns the removed ids of of.
func (m *HistoryMutation) RemovedOfIDs() (ids []int) {
	for id := range m.removedof {
		ids = append(ids, id)
	}
	return
}

// OfIDs returns the of ids in the mutation.
func (m *HistoryMutation) OfIDs() (ids []int) {
	for id := range m.of {
		ids = append(ids, id)
	}
	return
}

// ResetOf reset all changes of the "of" edge.
func (m *HistoryMutation) ResetOf() {
	m.of = nil
	m.clearedof = false
	m.removedof = nil
}

// Op returns the operation name.
func (m *HistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (History).
func (m *HistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HistoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.open_at != nil {
		fields = append(fields, history.FieldOpenAt)
	}
	if m.close_at != nil {
		fields = append(fields, history.FieldCloseAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case history.FieldOpenAt:
		return m.OpenAt()
	case history.FieldCloseAt:
		return m.CloseAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case history.FieldOpenAt:
		return m.OldOpenAt(ctx)
	case history.FieldCloseAt:
		return m.OldCloseAt(ctx)
	}
	return nil, fmt.Errorf("unknown History field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case history.FieldOpenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenAt(v)
		return nil
	case history.FieldCloseAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseAt(v)
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown History numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown History nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HistoryMutation) ResetField(name string) error {
	switch name {
	case history.FieldOpenAt:
		m.ResetOpenAt()
		return nil
	case history.FieldCloseAt:
		m.ResetCloseAt()
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.of != nil {
		edges = append(edges, history.EdgeOf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case history.EdgeOf:
		ids := make([]ent.Value, 0, len(m.of))
		for id := range m.of {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedof != nil {
		edges = append(edges, history.EdgeOf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case history.EdgeOf:
		ids := make([]ent.Value, 0, len(m.removedof))
		for id := range m.removedof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedof {
		edges = append(edges, history.EdgeOf)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case history.EdgeOf:
		return m.clearedof
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HistoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown History unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HistoryMutation) ResetEdge(name string) error {
	switch name {
	case history.EdgeOf:
		m.ResetOf()
		return nil
	}
	return fmt.Errorf("unknown History edge %s", name)
}

// MenuMutation represents an operation that mutate the Menus
// nodes in the graph.
type MenuMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	description    *string
	price          **money.Money
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	images         map[int]struct{}
	removedimages  map[int]struct{}
	clearedimages  bool
	options        map[int]struct{}
	removedoptions map[int]struct{}
	clearedoptions bool
	done           bool
	oldValue       func(context.Context) (*Menu, error)
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows to manage the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for $n.Name.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the id field of the mutation.
func withMenuID(id int) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *MenuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *MenuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *MenuMutation) ResetDescription() {
	m.description = nil
}

// SetPrice sets the price field.
func (m *MenuMutation) SetPrice(value *money.Money) {
	m.price = &value
}

// Price returns the price value in the mutation.
func (m *MenuMutation) Price() (r *money.Money, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldPrice(ctx context.Context) (v *money.Money, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of price.
func (m *MenuMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[menu.FieldPrice] = struct{}{}
}

// PriceCleared returns if the field price was cleared in this mutation.
func (m *MenuMutation) PriceCleared() bool {
	_, ok := m.clearedFields[menu.FieldPrice]
	return ok
}

// ResetPrice reset all changes of the "price" field.
func (m *MenuMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, menu.FieldPrice)
}

// SetOwnerID sets the owner edge to Restaurant by id.
func (m *MenuMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Restaurant.
func (m *MenuMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *MenuMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *MenuMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *MenuMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddImageIDs adds the images edge to File by ids.
func (m *MenuMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the images edge to File.
func (m *MenuMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared returns if the edge images was cleared.
func (m *MenuMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the images edge to File by ids.
func (m *MenuMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed ids of images.
func (m *MenuMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the images ids in the mutation.
func (m *MenuMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages reset all changes of the "images" edge.
func (m *MenuMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddOptionIDs adds the options edge to Menu by ids.
func (m *MenuMutation) AddOptionIDs(ids ...int) {
	if m.options == nil {
		m.options = make(map[int]struct{})
	}
	for i := range ids {
		m.options[ids[i]] = struct{}{}
	}
}

// ClearOptions clears the options edge to Menu.
func (m *MenuMutation) ClearOptions() {
	m.clearedoptions = true
}

// OptionsCleared returns if the edge options was cleared.
func (m *MenuMutation) OptionsCleared() bool {
	return m.clearedoptions
}

// RemoveOptionIDs removes the options edge to Menu by ids.
func (m *MenuMutation) RemoveOptionIDs(ids ...int) {
	if m.removedoptions == nil {
		m.removedoptions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoptions[ids[i]] = struct{}{}
	}
}

// RemovedOptions returns the removed ids of options.
func (m *MenuMutation) RemovedOptionsIDs() (ids []int) {
	for id := range m.removedoptions {
		ids = append(ids, id)
	}
	return
}

// OptionsIDs returns the options ids in the mutation.
func (m *MenuMutation) OptionsIDs() (ids []int) {
	for id := range m.options {
		ids = append(ids, id)
	}
	return
}

// ResetOptions reset all changes of the "options" edge.
func (m *MenuMutation) ResetOptions() {
	m.options = nil
	m.clearedoptions = false
	m.removedoptions = nil
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.description != nil {
		fields = append(fields, menu.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, menu.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldName:
		return m.Name()
	case menu.FieldDescription:
		return m.Description()
	case menu.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldDescription:
		return m.OldDescription(ctx)
	case menu.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case menu.FieldPrice:
		v, ok := value.(*money.Money)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MenuMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldPrice) {
		fields = append(fields, menu.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldDescription:
		m.ResetDescription()
		return nil
	case menu.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, menu.EdgeOwner)
	}
	if m.images != nil {
		edges = append(edges, menu.EdgeImages)
	}
	if m.options != nil {
		edges = append(edges, menu.EdgeOptions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.options))
		for id := range m.options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedimages != nil {
		edges = append(edges, menu.EdgeImages)
	}
	if m.removedoptions != nil {
		edges = append(edges, menu.EdgeOptions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.removedoptions))
		for id := range m.removedoptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, menu.EdgeOwner)
	}
	if m.clearedimages {
		edges = append(edges, menu.EdgeImages)
	}
	if m.clearedoptions {
		edges = append(edges, menu.EdgeOptions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeOwner:
		return m.clearedowner
	case menu.EdgeImages:
		return m.clearedimages
	case menu.EdgeOptions:
		return m.clearedoptions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeOwner:
		m.ResetOwner()
		return nil
	case menu.EdgeImages:
		m.ResetImages()
		return nil
	case menu.EdgeOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OrderMutation represents an operation that mutate the Orders
// nodes in the graph.
type OrderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	order_at      *time.Time
	delivery_at   *time.Time
	arrive_at     *time.Time
	clearedFields map[string]struct{}
	items         map[int]struct{}
	removeditems  map[int]struct{}
	cleareditems  bool
	who           *int
	clearedwho    bool
	done          bool
	oldValue      func(context.Context) (*Order, error)
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows to manage the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for $n.Name.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the id field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOrderAt sets the order_at field.
func (m *OrderMutation) SetOrderAt(t time.Time) {
	m.order_at = &t
}

// OrderAt returns the order_at value in the mutation.
func (m *OrderMutation) OrderAt() (r time.Time, exists bool) {
	v := m.order_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAt returns the old order_at value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldOrderAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAt: %w", err)
	}
	return oldValue.OrderAt, nil
}

// ResetOrderAt reset all changes of the "order_at" field.
func (m *OrderMutation) ResetOrderAt() {
	m.order_at = nil
}

// SetDeliveryAt sets the delivery_at field.
func (m *OrderMutation) SetDeliveryAt(t time.Time) {
	m.delivery_at = &t
}

// DeliveryAt returns the delivery_at value in the mutation.
func (m *OrderMutation) DeliveryAt() (r time.Time, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old delivery_at value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldDeliveryAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeliveryAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// ResetDeliveryAt reset all changes of the "delivery_at" field.
func (m *OrderMutation) ResetDeliveryAt() {
	m.delivery_at = nil
}

// SetArriveAt sets the arrive_at field.
func (m *OrderMutation) SetArriveAt(t time.Time) {
	m.arrive_at = &t
}

// ArriveAt returns the arrive_at value in the mutation.
func (m *OrderMutation) ArriveAt() (r time.Time, exists bool) {
	v := m.arrive_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArriveAt returns the old arrive_at value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldArriveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArriveAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArriveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArriveAt: %w", err)
	}
	return oldValue.ArriveAt, nil
}

// ResetArriveAt reset all changes of the "arrive_at" field.
func (m *OrderMutation) ResetArriveAt() {
	m.arrive_at = nil
}

// AddItemIDs adds the items edge to OrderField by ids.
func (m *OrderMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the items edge to OrderField.
func (m *OrderMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared returns if the edge items was cleared.
func (m *OrderMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the items edge to OrderField by ids.
func (m *OrderMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed ids of items.
func (m *OrderMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the items ids in the mutation.
func (m *OrderMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems reset all changes of the "items" edge.
func (m *OrderMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetWhoID sets the who edge to User by id.
func (m *OrderMutation) SetWhoID(id int) {
	m.who = &id
}

// ClearWho clears the who edge to User.
func (m *OrderMutation) ClearWho() {
	m.clearedwho = true
}

// WhoCleared returns if the edge who was cleared.
func (m *OrderMutation) WhoCleared() bool {
	return m.clearedwho
}

// WhoID returns the who id in the mutation.
func (m *OrderMutation) WhoID() (id int, exists bool) {
	if m.who != nil {
		return *m.who, true
	}
	return
}

// WhoIDs returns the who ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WhoID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) WhoIDs() (ids []int) {
	if id := m.who; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWho reset all changes of the "who" edge.
func (m *OrderMutation) ResetWho() {
	m.who = nil
	m.clearedwho = false
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.order_at != nil {
		fields = append(fields, order.FieldOrderAt)
	}
	if m.delivery_at != nil {
		fields = append(fields, order.FieldDeliveryAt)
	}
	if m.arrive_at != nil {
		fields = append(fields, order.FieldArriveAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldOrderAt:
		return m.OrderAt()
	case order.FieldDeliveryAt:
		return m.DeliveryAt()
	case order.FieldArriveAt:
		return m.ArriveAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldOrderAt:
		return m.OldOrderAt(ctx)
	case order.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case order.FieldArriveAt:
		return m.OldArriveAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldOrderAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAt(v)
		return nil
	case order.FieldDeliveryAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case order.FieldArriveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArriveAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldOrderAt:
		m.ResetOrderAt()
		return nil
	case order.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case order.FieldArriveAt:
		m.ResetArriveAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.items != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.who != nil {
		edges = append(edges, order.EdgeWho)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeWho:
		if id := m.who; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, order.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditems {
		edges = append(edges, order.EdgeItems)
	}
	if m.clearedwho {
		edges = append(edges, order.EdgeWho)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeItems:
		return m.cleareditems
	case order.EdgeWho:
		return m.clearedwho
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeWho:
		m.ClearWho()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeItems:
		m.ResetItems()
		return nil
	case order.EdgeWho:
		m.ResetWho()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderFieldMutation represents an operation that mutate the OrderFields
// nodes in the graph.
type OrderFieldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	count         *uint16
	addcount      *uint16
	clearedFields map[string]struct{}
	menu          map[int]struct{}
	removedmenu   map[int]struct{}
	clearedmenu   bool
	done          bool
	oldValue      func(context.Context) (*OrderField, error)
}

var _ ent.Mutation = (*OrderFieldMutation)(nil)

// orderfieldOption allows to manage the mutation configuration using functional options.
type orderfieldOption func(*OrderFieldMutation)

// newOrderFieldMutation creates new mutation for $n.Name.
func newOrderFieldMutation(c config, op Op, opts ...orderfieldOption) *OrderFieldMutation {
	m := &OrderFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderFieldID sets the id field of the mutation.
func withOrderFieldID(id int) orderfieldOption {
	return func(m *OrderFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderField
		)
		m.oldValue = func(ctx context.Context) (*OrderField, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderField sets the old OrderField of the mutation.
func withOrderField(node *OrderField) orderfieldOption {
	return func(m *OrderFieldMutation) {
		m.oldValue = func(context.Context) (*OrderField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrderFieldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCount sets the count field.
func (m *OrderFieldMutation) SetCount(u uint16) {
	m.count = &u
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *OrderFieldMutation) Count() (r uint16, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the OrderField.
// If the OrderField object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderFieldMutation) OldCount(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds u to count.
func (m *OrderFieldMutation) AddCount(u uint16) {
	if m.addcount != nil {
		*m.addcount += u
	} else {
		m.addcount = &u
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *OrderFieldMutation) AddedCount() (r uint16, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *OrderFieldMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// AddMenuIDs adds the menu edge to Menu by ids.
func (m *OrderFieldMutation) AddMenuIDs(ids ...int) {
	if m.menu == nil {
		m.menu = make(map[int]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the menu edge to Menu.
func (m *OrderFieldMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared returns if the edge menu was cleared.
func (m *OrderFieldMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the menu edge to Menu by ids.
func (m *OrderFieldMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed ids of menu.
func (m *OrderFieldMutation) RemovedMenuIDs() (ids []int) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the menu ids in the mutation.
func (m *OrderFieldMutation) MenuIDs() (ids []int) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu reset all changes of the "menu" edge.
func (m *OrderFieldMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// Op returns the operation name.
func (m *OrderFieldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderField).
func (m *OrderFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrderFieldMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.count != nil {
		fields = append(fields, orderfield.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrderFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderfield.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrderFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderfield.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown OrderField field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderfield.FieldCount:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderField field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrderFieldMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, orderfield.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrderFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderfield.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderfield.FieldCount:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrderFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrderFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderField nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrderFieldMutation) ResetField(name string) error {
	switch name {
	case orderfield.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown OrderField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrderFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menu != nil {
		edges = append(edges, orderfield.EdgeMenu)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrderFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderfield.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrderFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmenu != nil {
		edges = append(edges, orderfield.EdgeMenu)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrderFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderfield.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrderFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenu {
		edges = append(edges, orderfield.EdgeMenu)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrderFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case orderfield.EdgeMenu:
		return m.clearedmenu
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrderFieldMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderField unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrderFieldMutation) ResetEdge(name string) error {
	switch name {
	case orderfield.EdgeMenu:
		m.ResetMenu()
		return nil
	}
	return fmt.Errorf("unknown OrderField edge %s", name)
}

// RestaurantMutation represents an operation that mutate the Restaurants
// nodes in the graph.
type RestaurantMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	sub_name         *string
	uri              **url.URL
	clearedFields    map[string]struct{}
	avatar           *int
	clearedavatar    bool
	root             *int
	clearedroot      bool
	children         map[int]struct{}
	removedchildren  map[int]struct{}
	clearedchildren  bool
	parent           *int
	clearedparent    bool
	histories        map[int]struct{}
	removedhistories map[int]struct{}
	clearedhistories bool
	menus            map[int]struct{}
	removedmenus     map[int]struct{}
	clearedmenus     bool
	done             bool
	oldValue         func(context.Context) (*Restaurant, error)
}

var _ ent.Mutation = (*RestaurantMutation)(nil)

// restaurantOption allows to manage the mutation configuration using functional options.
type restaurantOption func(*RestaurantMutation)

// newRestaurantMutation creates new mutation for $n.Name.
func newRestaurantMutation(c config, op Op, opts ...restaurantOption) *RestaurantMutation {
	m := &RestaurantMutation{
		config:        c,
		op:            op,
		typ:           TypeRestaurant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRestaurantID sets the id field of the mutation.
func withRestaurantID(id int) restaurantOption {
	return func(m *RestaurantMutation) {
		var (
			err   error
			once  sync.Once
			value *Restaurant
		)
		m.oldValue = func(ctx context.Context) (*Restaurant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Restaurant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRestaurant sets the old Restaurant of the mutation.
func withRestaurant(node *Restaurant) restaurantOption {
	return func(m *RestaurantMutation) {
		m.oldValue = func(context.Context) (*Restaurant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RestaurantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RestaurantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RestaurantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RestaurantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RestaurantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Restaurant.
// If the Restaurant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RestaurantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RestaurantMutation) ResetName() {
	m.name = nil
}

// SetSubName sets the sub_name field.
func (m *RestaurantMutation) SetSubName(s string) {
	m.sub_name = &s
}

// SubName returns the sub_name value in the mutation.
func (m *RestaurantMutation) SubName() (r string, exists bool) {
	v := m.sub_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubName returns the old sub_name value of the Restaurant.
// If the Restaurant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RestaurantMutation) OldSubName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubName: %w", err)
	}
	return oldValue.SubName, nil
}

// ClearSubName clears the value of sub_name.
func (m *RestaurantMutation) ClearSubName() {
	m.sub_name = nil
	m.clearedFields[restaurant.FieldSubName] = struct{}{}
}

// SubNameCleared returns if the field sub_name was cleared in this mutation.
func (m *RestaurantMutation) SubNameCleared() bool {
	_, ok := m.clearedFields[restaurant.FieldSubName]
	return ok
}

// ResetSubName reset all changes of the "sub_name" field.
func (m *RestaurantMutation) ResetSubName() {
	m.sub_name = nil
	delete(m.clearedFields, restaurant.FieldSubName)
}

// SetURI sets the uri field.
func (m *RestaurantMutation) SetURI(u *url.URL) {
	m.uri = &u
}

// URI returns the uri value in the mutation.
func (m *RestaurantMutation) URI() (r *url.URL, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old uri value of the Restaurant.
// If the Restaurant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RestaurantMutation) OldURI(ctx context.Context) (v *url.URL, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of uri.
func (m *RestaurantMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[restaurant.FieldURI] = struct{}{}
}

// URICleared returns if the field uri was cleared in this mutation.
func (m *RestaurantMutation) URICleared() bool {
	_, ok := m.clearedFields[restaurant.FieldURI]
	return ok
}

// ResetURI reset all changes of the "uri" field.
func (m *RestaurantMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, restaurant.FieldURI)
}

// SetAvatarID sets the avatar edge to File by id.
func (m *RestaurantMutation) SetAvatarID(id int) {
	m.avatar = &id
}

// ClearAvatar clears the avatar edge to File.
func (m *RestaurantMutation) ClearAvatar() {
	m.clearedavatar = true
}

// AvatarCleared returns if the edge avatar was cleared.
func (m *RestaurantMutation) AvatarCleared() bool {
	return m.clearedavatar
}

// AvatarID returns the avatar id in the mutation.
func (m *RestaurantMutation) AvatarID() (id int, exists bool) {
	if m.avatar != nil {
		return *m.avatar, true
	}
	return
}

// AvatarIDs returns the avatar ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AvatarID instead. It exists only for internal usage by the builders.
func (m *RestaurantMutation) AvatarIDs() (ids []int) {
	if id := m.avatar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAvatar reset all changes of the "avatar" edge.
func (m *RestaurantMutation) ResetAvatar() {
	m.avatar = nil
	m.clearedavatar = false
}

// SetRootID sets the root edge to Restaurant by id.
func (m *RestaurantMutation) SetRootID(id int) {
	m.root = &id
}

// ClearRoot clears the root edge to Restaurant.
func (m *RestaurantMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared returns if the edge root was cleared.
func (m *RestaurantMutation) RootCleared() bool {
	return m.clearedroot
}

// RootID returns the root id in the mutation.
func (m *RestaurantMutation) RootID() (id int, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the root ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *RestaurantMutation) RootIDs() (ids []int) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot reset all changes of the "root" edge.
func (m *RestaurantMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddChildIDs adds the children edge to Restaurant by ids.
func (m *RestaurantMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the children edge to Restaurant.
func (m *RestaurantMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared returns if the edge children was cleared.
func (m *RestaurantMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the children edge to Restaurant by ids.
func (m *RestaurantMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *RestaurantMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *RestaurantMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the "children" edge.
func (m *RestaurantMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the parent edge to Restaurant by id.
func (m *RestaurantMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Restaurant.
func (m *RestaurantMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *RestaurantMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *RestaurantMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *RestaurantMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *RestaurantMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddHistoryIDs adds the histories edge to History by ids.
func (m *RestaurantMutation) AddHistoryIDs(ids ...int) {
	if m.histories == nil {
		m.histories = make(map[int]struct{})
	}
	for i := range ids {
		m.histories[ids[i]] = struct{}{}
	}
}

// ClearHistories clears the histories edge to History.
func (m *RestaurantMutation) ClearHistories() {
	m.clearedhistories = true
}

// HistoriesCleared returns if the edge histories was cleared.
func (m *RestaurantMutation) HistoriesCleared() bool {
	return m.clearedhistories
}

// RemoveHistoryIDs removes the histories edge to History by ids.
func (m *RestaurantMutation) RemoveHistoryIDs(ids ...int) {
	if m.removedhistories == nil {
		m.removedhistories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistories[ids[i]] = struct{}{}
	}
}

// RemovedHistories returns the removed ids of histories.
func (m *RestaurantMutation) RemovedHistoriesIDs() (ids []int) {
	for id := range m.removedhistories {
		ids = append(ids, id)
	}
	return
}

// HistoriesIDs returns the histories ids in the mutation.
func (m *RestaurantMutation) HistoriesIDs() (ids []int) {
	for id := range m.histories {
		ids = append(ids, id)
	}
	return
}

// ResetHistories reset all changes of the "histories" edge.
func (m *RestaurantMutation) ResetHistories() {
	m.histories = nil
	m.clearedhistories = false
	m.removedhistories = nil
}

// AddMenuIDs adds the menus edge to Menu by ids.
func (m *RestaurantMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the menus edge to Menu.
func (m *RestaurantMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared returns if the edge menus was cleared.
func (m *RestaurantMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the menus edge to Menu by ids.
func (m *RestaurantMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed ids of menus.
func (m *RestaurantMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the menus ids in the mutation.
func (m *RestaurantMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus reset all changes of the "menus" edge.
func (m *RestaurantMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Op returns the operation name.
func (m *RestaurantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Restaurant).
func (m *RestaurantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RestaurantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, restaurant.FieldName)
	}
	if m.sub_name != nil {
		fields = append(fields, restaurant.FieldSubName)
	}
	if m.uri != nil {
		fields = append(fields, restaurant.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RestaurantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case restaurant.FieldName:
		return m.Name()
	case restaurant.FieldSubName:
		return m.SubName()
	case restaurant.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RestaurantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case restaurant.FieldName:
		return m.OldName(ctx)
	case restaurant.FieldSubName:
		return m.OldSubName(ctx)
	case restaurant.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown Restaurant field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RestaurantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case restaurant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case restaurant.FieldSubName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubName(v)
		return nil
	case restaurant.FieldURI:
		v, ok := value.(*url.URL)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown Restaurant field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RestaurantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RestaurantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RestaurantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Restaurant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RestaurantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(restaurant.FieldSubName) {
		fields = append(fields, restaurant.FieldSubName)
	}
	if m.FieldCleared(restaurant.FieldURI) {
		fields = append(fields, restaurant.FieldURI)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RestaurantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RestaurantMutation) ClearField(name string) error {
	switch name {
	case restaurant.FieldSubName:
		m.ClearSubName()
		return nil
	case restaurant.FieldURI:
		m.ClearURI()
		return nil
	}
	return fmt.Errorf("unknown Restaurant nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RestaurantMutation) ResetField(name string) error {
	switch name {
	case restaurant.FieldName:
		m.ResetName()
		return nil
	case restaurant.FieldSubName:
		m.ResetSubName()
		return nil
	case restaurant.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown Restaurant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RestaurantMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.avatar != nil {
		edges = append(edges, restaurant.EdgeAvatar)
	}
	if m.root != nil {
		edges = append(edges, restaurant.EdgeRoot)
	}
	if m.children != nil {
		edges = append(edges, restaurant.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, restaurant.EdgeParent)
	}
	if m.histories != nil {
		edges = append(edges, restaurant.EdgeHistories)
	}
	if m.menus != nil {
		edges = append(edges, restaurant.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RestaurantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case restaurant.EdgeAvatar:
		if id := m.avatar; id != nil {
			return []ent.Value{*id}
		}
	case restaurant.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case restaurant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case restaurant.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.histories))
		for id := range m.histories {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RestaurantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchildren != nil {
		edges = append(edges, restaurant.EdgeChildren)
	}
	if m.removedhistories != nil {
		edges = append(edges, restaurant.EdgeHistories)
	}
	if m.removedmenus != nil {
		edges = append(edges, restaurant.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RestaurantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case restaurant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeHistories:
		ids := make([]ent.Value, 0, len(m.removedhistories))
		for id := range m.removedhistories {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RestaurantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedavatar {
		edges = append(edges, restaurant.EdgeAvatar)
	}
	if m.clearedroot {
		edges = append(edges, restaurant.EdgeRoot)
	}
	if m.clearedchildren {
		edges = append(edges, restaurant.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, restaurant.EdgeParent)
	}
	if m.clearedhistories {
		edges = append(edges, restaurant.EdgeHistories)
	}
	if m.clearedmenus {
		edges = append(edges, restaurant.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RestaurantMutation) EdgeCleared(name string) bool {
	switch name {
	case restaurant.EdgeAvatar:
		return m.clearedavatar
	case restaurant.EdgeRoot:
		return m.clearedroot
	case restaurant.EdgeChildren:
		return m.clearedchildren
	case restaurant.EdgeParent:
		return m.clearedparent
	case restaurant.EdgeHistories:
		return m.clearedhistories
	case restaurant.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RestaurantMutation) ClearEdge(name string) error {
	switch name {
	case restaurant.EdgeAvatar:
		m.ClearAvatar()
		return nil
	case restaurant.EdgeRoot:
		m.ClearRoot()
		return nil
	case restaurant.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Restaurant unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RestaurantMutation) ResetEdge(name string) error {
	switch name {
	case restaurant.EdgeAvatar:
		m.ResetAvatar()
		return nil
	case restaurant.EdgeRoot:
		m.ResetRoot()
		return nil
	case restaurant.EdgeChildren:
		m.ResetChildren()
		return nil
	case restaurant.EdgeParent:
		m.ResetParent()
		return nil
	case restaurant.EdgeHistories:
		m.ResetHistories()
		return nil
	case restaurant.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Restaurant edge %s", name)
}

// ReviewMutation represents an operation that mutate the Reviews
// nodes in the graph.
type ReviewMutation struct {
	config
	op            Op
	typ           string
	id            *int
	write_at      *time.Time
	title         *string
	contents      *string
	is_delete     *bool
	clearedFields map[string]struct{}
	_order        *int
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*Review, error)
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows to manage the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for $n.Name.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the id field of the mutation.
func withReviewID(id int) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWriteAt sets the write_at field.
func (m *ReviewMutation) SetWriteAt(t time.Time) {
	m.write_at = &t
}

// WriteAt returns the write_at value in the mutation.
func (m *ReviewMutation) WriteAt() (r time.Time, exists bool) {
	v := m.write_at
	if v == nil {
		return
	}
	return *v, true
}

// OldWriteAt returns the old write_at value of the Review.
// If the Review object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReviewMutation) OldWriteAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWriteAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWriteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWriteAt: %w", err)
	}
	return oldValue.WriteAt, nil
}

// ResetWriteAt reset all changes of the "write_at" field.
func (m *ReviewMutation) ResetWriteAt() {
	m.write_at = nil
}

// SetTitle sets the title field.
func (m *ReviewMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *ReviewMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Review.
// If the Review object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReviewMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *ReviewMutation) ResetTitle() {
	m.title = nil
}

// SetContents sets the contents field.
func (m *ReviewMutation) SetContents(s string) {
	m.contents = &s
}

// Contents returns the contents value in the mutation.
func (m *ReviewMutation) Contents() (r string, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old contents value of the Review.
// If the Review object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReviewMutation) OldContents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContents is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents reset all changes of the "contents" field.
func (m *ReviewMutation) ResetContents() {
	m.contents = nil
}

// SetIsDelete sets the is_delete field.
func (m *ReviewMutation) SetIsDelete(b bool) {
	m.is_delete = &b
}

// IsDelete returns the is_delete value in the mutation.
func (m *ReviewMutation) IsDelete() (r bool, exists bool) {
	v := m.is_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelete returns the old is_delete value of the Review.
// If the Review object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReviewMutation) OldIsDelete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDelete is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelete: %w", err)
	}
	return oldValue.IsDelete, nil
}

// ResetIsDelete reset all changes of the "is_delete" field.
func (m *ReviewMutation) ResetIsDelete() {
	m.is_delete = nil
}

// SetOrderID sets the order edge to Order by id.
func (m *ReviewMutation) SetOrderID(id int) {
	m._order = &id
}

// ClearOrder clears the order edge to Order.
func (m *ReviewMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared returns if the edge order was cleared.
func (m *ReviewMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the order id in the mutation.
func (m *ReviewMutation) OrderID() (id int, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *ReviewMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.write_at != nil {
		fields = append(fields, review.FieldWriteAt)
	}
	if m.title != nil {
		fields = append(fields, review.FieldTitle)
	}
	if m.contents != nil {
		fields = append(fields, review.FieldContents)
	}
	if m.is_delete != nil {
		fields = append(fields, review.FieldIsDelete)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldWriteAt:
		return m.WriteAt()
	case review.FieldTitle:
		return m.Title()
	case review.FieldContents:
		return m.Contents()
	case review.FieldIsDelete:
		return m.IsDelete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldWriteAt:
		return m.OldWriteAt(ctx)
	case review.FieldTitle:
		return m.OldTitle(ctx)
	case review.FieldContents:
		return m.OldContents(ctx)
	case review.FieldIsDelete:
		return m.OldIsDelete(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldWriteAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWriteAt(v)
		return nil
	case review.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case review.FieldContents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	case review.FieldIsDelete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelete(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldWriteAt:
		m.ResetWriteAt()
		return nil
	case review.FieldTitle:
		m.ResetTitle()
		return nil
	case review.FieldContents:
		m.ResetContents()
		return nil
	case review.FieldIsDelete:
		m.ResetIsDelete()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, review.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, review.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	address       *string
	clearedFields map[string]struct{}
	auths         map[int]struct{}
	removedauths  map[int]struct{}
	clearedauths  bool
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the address field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// AddAuthIDs adds the auths edge to Authorize by ids.
func (m *UserMutation) AddAuthIDs(ids ...int) {
	if m.auths == nil {
		m.auths = make(map[int]struct{})
	}
	for i := range ids {
		m.auths[ids[i]] = struct{}{}
	}
}

// ClearAuths clears the auths edge to Authorize.
func (m *UserMutation) ClearAuths() {
	m.clearedauths = true
}

// AuthsCleared returns if the edge auths was cleared.
func (m *UserMutation) AuthsCleared() bool {
	return m.clearedauths
}

// RemoveAuthIDs removes the auths edge to Authorize by ids.
func (m *UserMutation) RemoveAuthIDs(ids ...int) {
	if m.removedauths == nil {
		m.removedauths = make(map[int]struct{})
	}
	for i := range ids {
		m.removedauths[ids[i]] = struct{}{}
	}
}

// RemovedAuths returns the removed ids of auths.
func (m *UserMutation) RemovedAuthsIDs() (ids []int) {
	for id := range m.removedauths {
		ids = append(ids, id)
	}
	return
}

// AuthsIDs returns the auths ids in the mutation.
func (m *UserMutation) AuthsIDs() (ids []int) {
	for id := range m.auths {
		ids = append(ids, id)
	}
	return
}

// ResetAuths reset all changes of the "auths" edge.
func (m *UserMutation) ResetAuths() {
	m.auths = nil
	m.clearedauths = false
	m.removedauths = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.auths != nil {
		edges = append(edges, user.EdgeAuths)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.auths))
		for id := range m.auths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedauths != nil {
		edges = append(edges, user.EdgeAuths)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.removedauths))
		for id := range m.removedauths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauths {
		edges = append(edges, user.EdgeAuths)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuths:
		return m.clearedauths
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuths:
		m.ResetAuths()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
