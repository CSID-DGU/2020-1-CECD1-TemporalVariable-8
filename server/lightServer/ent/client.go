// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"lightServer/ent/migrate"

	"lightServer/ent/authorize"
	"lightServer/ent/category"
	"lightServer/ent/file"
	"lightServer/ent/history"
	"lightServer/ent/menu"
	"lightServer/ent/order"
	"lightServer/ent/orderfield"
	"lightServer/ent/restaurant"
	"lightServer/ent/review"
	"lightServer/ent/user"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Authorize is the client for interacting with the Authorize builders.
	Authorize *AuthorizeClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// History is the client for interacting with the History builders.
	History *HistoryClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderField is the client for interacting with the OrderField builders.
	OrderField *OrderFieldClient
	// Restaurant is the client for interacting with the Restaurant builders.
	Restaurant *RestaurantClient
	// Review is the client for interacting with the Review builders.
	Review *ReviewClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Authorize = NewAuthorizeClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.File = NewFileClient(c.config)
	c.History = NewHistoryClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderField = NewOrderFieldClient(c.config)
	c.Restaurant = NewRestaurantClient(c.config)
	c.Review = NewReviewClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Authorize:  NewAuthorizeClient(cfg),
		Category:   NewCategoryClient(cfg),
		File:       NewFileClient(cfg),
		History:    NewHistoryClient(cfg),
		Menu:       NewMenuClient(cfg),
		Order:      NewOrderClient(cfg),
		OrderField: NewOrderFieldClient(cfg),
		Restaurant: NewRestaurantClient(cfg),
		Review:     NewReviewClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:     cfg,
		Authorize:  NewAuthorizeClient(cfg),
		Category:   NewCategoryClient(cfg),
		File:       NewFileClient(cfg),
		History:    NewHistoryClient(cfg),
		Menu:       NewMenuClient(cfg),
		Order:      NewOrderClient(cfg),
		OrderField: NewOrderFieldClient(cfg),
		Restaurant: NewRestaurantClient(cfg),
		Review:     NewReviewClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Authorize.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Authorize.Use(hooks...)
	c.Category.Use(hooks...)
	c.File.Use(hooks...)
	c.History.Use(hooks...)
	c.Menu.Use(hooks...)
	c.Order.Use(hooks...)
	c.OrderField.Use(hooks...)
	c.Restaurant.Use(hooks...)
	c.Review.Use(hooks...)
	c.User.Use(hooks...)
}

// AuthorizeClient is a client for the Authorize schema.
type AuthorizeClient struct {
	config
}

// NewAuthorizeClient returns a client for the Authorize from the given config.
func NewAuthorizeClient(c config) *AuthorizeClient {
	return &AuthorizeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorize.Hooks(f(g(h())))`.
func (c *AuthorizeClient) Use(hooks ...Hook) {
	c.hooks.Authorize = append(c.hooks.Authorize, hooks...)
}

// Create returns a create builder for Authorize.
func (c *AuthorizeClient) Create() *AuthorizeCreate {
	mutation := newAuthorizeMutation(c.config, OpCreate)
	return &AuthorizeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Authorize entities.
func (c *AuthorizeClient) CreateBulk(builders ...*AuthorizeCreate) *AuthorizeCreateBulk {
	return &AuthorizeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Authorize.
func (c *AuthorizeClient) Update() *AuthorizeUpdate {
	mutation := newAuthorizeMutation(c.config, OpUpdate)
	return &AuthorizeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizeClient) UpdateOne(a *Authorize) *AuthorizeUpdateOne {
	mutation := newAuthorizeMutation(c.config, OpUpdateOne, withAuthorize(a))
	return &AuthorizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizeClient) UpdateOneID(id int) *AuthorizeUpdateOne {
	mutation := newAuthorizeMutation(c.config, OpUpdateOne, withAuthorizeID(id))
	return &AuthorizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Authorize.
func (c *AuthorizeClient) Delete() *AuthorizeDelete {
	mutation := newAuthorizeMutation(c.config, OpDelete)
	return &AuthorizeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthorizeClient) DeleteOne(a *Authorize) *AuthorizeDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthorizeClient) DeleteOneID(id int) *AuthorizeDeleteOne {
	builder := c.Delete().Where(authorize.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizeDeleteOne{builder}
}

// Query returns a query builder for Authorize.
func (c *AuthorizeClient) Query() *AuthorizeQuery {
	return &AuthorizeQuery{config: c.config}
}

// Get returns a Authorize entity by its id.
func (c *AuthorizeClient) Get(ctx context.Context, id int) (*Authorize, error) {
	return c.Query().Where(authorize.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizeClient) GetX(ctx context.Context, id int) *Authorize {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Authorize.
func (c *AuthorizeClient) QueryUser(a *Authorize) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorize.Table, authorize.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, authorize.UserTable, authorize.UserColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizeClient) Hooks() []Hook {
	return c.hooks.Authorize
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Create returns a create builder for Category.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{config: c.config}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Category.
func (c *CategoryClient) QueryOwner(ca *Category) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, category.OwnerTable, category.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Category.
func (c *CategoryClient) QueryMenus(ca *Category) *MenuQuery {
	query := &MenuQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.MenusTable, category.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Create returns a create builder for File.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id int) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FileClient) DeleteOneID(id int) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{config: c.config}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id int) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id int) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// HistoryClient is a client for the History schema.
type HistoryClient struct {
	config
}

// NewHistoryClient returns a client for the History from the given config.
func NewHistoryClient(c config) *HistoryClient {
	return &HistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `history.Hooks(f(g(h())))`.
func (c *HistoryClient) Use(hooks ...Hook) {
	c.hooks.History = append(c.hooks.History, hooks...)
}

// Create returns a create builder for History.
func (c *HistoryClient) Create() *HistoryCreate {
	mutation := newHistoryMutation(c.config, OpCreate)
	return &HistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of History entities.
func (c *HistoryClient) CreateBulk(builders ...*HistoryCreate) *HistoryCreateBulk {
	return &HistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for History.
func (c *HistoryClient) Update() *HistoryUpdate {
	mutation := newHistoryMutation(c.config, OpUpdate)
	return &HistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HistoryClient) UpdateOne(h *History) *HistoryUpdateOne {
	mutation := newHistoryMutation(c.config, OpUpdateOne, withHistory(h))
	return &HistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HistoryClient) UpdateOneID(id int) *HistoryUpdateOne {
	mutation := newHistoryMutation(c.config, OpUpdateOne, withHistoryID(id))
	return &HistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for History.
func (c *HistoryClient) Delete() *HistoryDelete {
	mutation := newHistoryMutation(c.config, OpDelete)
	return &HistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *HistoryClient) DeleteOne(h *History) *HistoryDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *HistoryClient) DeleteOneID(id int) *HistoryDeleteOne {
	builder := c.Delete().Where(history.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HistoryDeleteOne{builder}
}

// Query returns a query builder for History.
func (c *HistoryClient) Query() *HistoryQuery {
	return &HistoryQuery{config: c.config}
}

// Get returns a History entity by its id.
func (c *HistoryClient) Get(ctx context.Context, id int) (*History, error) {
	return c.Query().Where(history.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HistoryClient) GetX(ctx context.Context, id int) *History {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOf queries the of edge of a History.
func (c *HistoryClient) QueryOf(h *History) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(history.Table, history.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, history.OfTable, history.OfPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HistoryClient) Hooks() []Hook {
	return c.hooks.History
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Create returns a create builder for Menu.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id int) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MenuClient) DeleteOneID(id int) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{config: c.config}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id int) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id int) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Menu.
func (c *MenuClient) QueryOwner(m *Menu) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, menu.OwnerTable, menu.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a Menu.
func (c *MenuClient) QueryImages(m *Menu) *FileQuery {
	query := &FileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ImagesTable, menu.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOptions queries the options edge of a Menu.
func (c *MenuClient) QueryOptions(m *Menu) *MenuQuery {
	query := &MenuQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menu.OptionsTable, menu.OptionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Create returns a create builder for Order.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *OrderClient) DeleteOneID(id int) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{config: c.config}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Order.
func (c *OrderClient) QueryItems(o *Order) *OrderFieldQuery {
	query := &OrderFieldQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderfield.Table, orderfield.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemsTable, order.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWho queries the who edge of a Order.
func (c *OrderClient) QueryWho(o *Order) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.WhoTable, order.WhoColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// OrderFieldClient is a client for the OrderField schema.
type OrderFieldClient struct {
	config
}

// NewOrderFieldClient returns a client for the OrderField from the given config.
func NewOrderFieldClient(c config) *OrderFieldClient {
	return &OrderFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderfield.Hooks(f(g(h())))`.
func (c *OrderFieldClient) Use(hooks ...Hook) {
	c.hooks.OrderField = append(c.hooks.OrderField, hooks...)
}

// Create returns a create builder for OrderField.
func (c *OrderFieldClient) Create() *OrderFieldCreate {
	mutation := newOrderFieldMutation(c.config, OpCreate)
	return &OrderFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of OrderField entities.
func (c *OrderFieldClient) CreateBulk(builders ...*OrderFieldCreate) *OrderFieldCreateBulk {
	return &OrderFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderField.
func (c *OrderFieldClient) Update() *OrderFieldUpdate {
	mutation := newOrderFieldMutation(c.config, OpUpdate)
	return &OrderFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderFieldClient) UpdateOne(of *OrderField) *OrderFieldUpdateOne {
	mutation := newOrderFieldMutation(c.config, OpUpdateOne, withOrderField(of))
	return &OrderFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderFieldClient) UpdateOneID(id int) *OrderFieldUpdateOne {
	mutation := newOrderFieldMutation(c.config, OpUpdateOne, withOrderFieldID(id))
	return &OrderFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderField.
func (c *OrderFieldClient) Delete() *OrderFieldDelete {
	mutation := newOrderFieldMutation(c.config, OpDelete)
	return &OrderFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *OrderFieldClient) DeleteOne(of *OrderField) *OrderFieldDeleteOne {
	return c.DeleteOneID(of.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *OrderFieldClient) DeleteOneID(id int) *OrderFieldDeleteOne {
	builder := c.Delete().Where(orderfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderFieldDeleteOne{builder}
}

// Query returns a query builder for OrderField.
func (c *OrderFieldClient) Query() *OrderFieldQuery {
	return &OrderFieldQuery{config: c.config}
}

// Get returns a OrderField entity by its id.
func (c *OrderFieldClient) Get(ctx context.Context, id int) (*OrderField, error) {
	return c.Query().Where(orderfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderFieldClient) GetX(ctx context.Context, id int) *OrderField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenu queries the menu edge of a OrderField.
func (c *OrderFieldClient) QueryMenu(of *OrderField) *MenuQuery {
	query := &MenuQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := of.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderfield.Table, orderfield.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orderfield.MenuTable, orderfield.MenuColumn),
		)
		fromV = sqlgraph.Neighbors(of.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderFieldClient) Hooks() []Hook {
	return c.hooks.OrderField
}

// RestaurantClient is a client for the Restaurant schema.
type RestaurantClient struct {
	config
}

// NewRestaurantClient returns a client for the Restaurant from the given config.
func NewRestaurantClient(c config) *RestaurantClient {
	return &RestaurantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `restaurant.Hooks(f(g(h())))`.
func (c *RestaurantClient) Use(hooks ...Hook) {
	c.hooks.Restaurant = append(c.hooks.Restaurant, hooks...)
}

// Create returns a create builder for Restaurant.
func (c *RestaurantClient) Create() *RestaurantCreate {
	mutation := newRestaurantMutation(c.config, OpCreate)
	return &RestaurantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Restaurant entities.
func (c *RestaurantClient) CreateBulk(builders ...*RestaurantCreate) *RestaurantCreateBulk {
	return &RestaurantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Restaurant.
func (c *RestaurantClient) Update() *RestaurantUpdate {
	mutation := newRestaurantMutation(c.config, OpUpdate)
	return &RestaurantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RestaurantClient) UpdateOne(r *Restaurant) *RestaurantUpdateOne {
	mutation := newRestaurantMutation(c.config, OpUpdateOne, withRestaurant(r))
	return &RestaurantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RestaurantClient) UpdateOneID(id int) *RestaurantUpdateOne {
	mutation := newRestaurantMutation(c.config, OpUpdateOne, withRestaurantID(id))
	return &RestaurantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Restaurant.
func (c *RestaurantClient) Delete() *RestaurantDelete {
	mutation := newRestaurantMutation(c.config, OpDelete)
	return &RestaurantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RestaurantClient) DeleteOne(r *Restaurant) *RestaurantDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RestaurantClient) DeleteOneID(id int) *RestaurantDeleteOne {
	builder := c.Delete().Where(restaurant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RestaurantDeleteOne{builder}
}

// Query returns a query builder for Restaurant.
func (c *RestaurantClient) Query() *RestaurantQuery {
	return &RestaurantQuery{config: c.config}
}

// Get returns a Restaurant entity by its id.
func (c *RestaurantClient) Get(ctx context.Context, id int) (*Restaurant, error) {
	return c.Query().Where(restaurant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RestaurantClient) GetX(ctx context.Context, id int) *Restaurant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAvatar queries the avatar edge of a Restaurant.
func (c *RestaurantClient) QueryAvatar(r *Restaurant) *FileQuery {
	query := &FileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, restaurant.AvatarTable, restaurant.AvatarColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoot queries the root edge of a Restaurant.
func (c *RestaurantClient) QueryRoot(r *Restaurant) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, restaurant.RootTable, restaurant.RootColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Restaurant.
func (c *RestaurantClient) QueryChildren(r *Restaurant) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, restaurant.ChildrenTable, restaurant.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Restaurant.
func (c *RestaurantClient) QueryParent(r *Restaurant) *RestaurantQuery {
	query := &RestaurantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(restaurant.Table, restaurant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, restaurant.ParentTable, restaurant.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHistories queries the histories edge of a Restaurant.
func (c *RestaurantClient) QueryHistories(r *Restaurant) *HistoryQuery {
	query := &HistoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(history.Table, history.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, restaurant.HistoriesTable, restaurant.HistoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Restaurant.
func (c *RestaurantClient) QueryMenus(r *Restaurant) *MenuQuery {
	query := &MenuQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(restaurant.Table, restaurant.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, restaurant.MenusTable, restaurant.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RestaurantClient) Hooks() []Hook {
	return c.hooks.Restaurant
}

// ReviewClient is a client for the Review schema.
type ReviewClient struct {
	config
}

// NewReviewClient returns a client for the Review from the given config.
func NewReviewClient(c config) *ReviewClient {
	return &ReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `review.Hooks(f(g(h())))`.
func (c *ReviewClient) Use(hooks ...Hook) {
	c.hooks.Review = append(c.hooks.Review, hooks...)
}

// Create returns a create builder for Review.
func (c *ReviewClient) Create() *ReviewCreate {
	mutation := newReviewMutation(c.config, OpCreate)
	return &ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Review entities.
func (c *ReviewClient) CreateBulk(builders ...*ReviewCreate) *ReviewCreateBulk {
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Review.
func (c *ReviewClient) Update() *ReviewUpdate {
	mutation := newReviewMutation(c.config, OpUpdate)
	return &ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewClient) UpdateOne(r *Review) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReview(r))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewClient) UpdateOneID(id int) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReviewID(id))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Review.
func (c *ReviewClient) Delete() *ReviewDelete {
	mutation := newReviewMutation(c.config, OpDelete)
	return &ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReviewClient) DeleteOne(r *Review) *ReviewDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReviewClient) DeleteOneID(id int) *ReviewDeleteOne {
	builder := c.Delete().Where(review.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewDeleteOne{builder}
}

// Query returns a query builder for Review.
func (c *ReviewClient) Query() *ReviewQuery {
	return &ReviewQuery{config: c.config}
}

// Get returns a Review entity by its id.
func (c *ReviewClient) Get(ctx context.Context, id int) (*Review, error) {
	return c.Query().Where(review.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewClient) GetX(ctx context.Context, id int) *Review {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a Review.
func (c *ReviewClient) QueryOrder(r *Review) *OrderQuery {
	query := &OrderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.OrderTable, review.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewClient) Hooks() []Hook {
	return c.hooks.Review
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuths queries the auths edge of a User.
func (c *UserClient) QueryAuths(u *User) *AuthorizeQuery {
	query := &AuthorizeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(authorize.Table, authorize.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuthsTable, user.AuthsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
